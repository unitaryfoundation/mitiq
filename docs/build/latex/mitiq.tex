%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{mitiq}
\date{Mar 21, 2020}
\release{0.1.0}
\author{Tech Team @ Unitary Fund}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Change Log}
\label{\detokenize{changelog:change-log}}\label{\detokenize{changelog:changelog}}\label{\detokenize{changelog::doc}}

\section{Version 0.1.0 (Date)}
\label{\detokenize{changelog:version-0-1-0-date}}\begin{itemize}
\item {} 
\sphinxstylestrong{Initial release.}

\end{itemize}


\chapter{Users Guide}
\label{\detokenize{guide/guide:users-guide}}\label{\detokenize{guide/guide:guide}}\label{\detokenize{guide/guide::doc}}

\section{Overview of mitiq}
\label{\detokenize{guide/guide-overview:overview-of-mitiq}}\label{\detokenize{guide/guide-overview::doc}}
Welcome to \sphinxtitleref{mitiq} Users Guide.

Mitiq is an open source toolkit for implementing error mitigation techniques on most current intermediate\sphinxhyphen{}scale quantum computers.

The library allows to postprocess results from quantum circuits with both analog and digital techniques, interfacing with a variety of quantum circuit libraries.


\section{Zero Noise Extrapolation}
\label{\detokenize{guide/guide-zne:zero-noise-extrapolation}}\label{\detokenize{guide/guide-zne::doc}}

\subsection{Introduction}
\label{\detokenize{guide/guide-zne:introduction}}
Zero noise extrapolation (ZNE) was introduced concurrently in Ref. {[}1{]} and {[}2{]}.
With \sphinxtitleref{mitiq.zne} module it is possible to extrapolate what the expected value would be without noise. This is done by first setting up one of the key objects in \sphinxtitleref{mitiq}, which is a \sphinxcode{\sphinxupquote{mitiq.Factory}} object.


\subsection{Importing Quantum Circuits}
\label{\detokenize{guide/guide-zne:importing-quantum-circuits}}
\sphinxtitleref{mitiq} allows one to flexibly import and export quantum circuits from other libraries. Here is an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{mitiq} \PYG{k+kn}{import} \PYG{n}{Factory}
\end{sphinxVerbatim}


\chapter{API\sphinxhyphen{}doc}
\label{\detokenize{index:module-mitiq}}\label{\detokenize{index:api-doc}}\index{mitiq (module)@\spxentry{mitiq}\spxextra{module}}
This is the top level module from which functions and classes of
Mitiq can be directly imported.
\index{version() (in module mitiq)@\spxentry{version()}\spxextra{in module mitiq}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.version}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mitiq.}}\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns the Mitiq version number.

\end{fulllineitems}



\section{Factories}
\label{\detokenize{index:module-mitiq.factories}}\label{\detokenize{index:factories}}\index{mitiq.factories (module)@\spxentry{mitiq.factories}\spxextra{module}}
Contains all the main classes corresponding to different zero\sphinxhyphen{}noise extrapolation methods.
\index{BatchedFactory (class in mitiq.factories)@\spxentry{BatchedFactory}\spxextra{class in mitiq.factories}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.BatchedFactory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mitiq.factories.}}\sphinxbfcode{\sphinxupquote{BatchedFactory}}}{\emph{scalars: Iterable{[}float{]}}}{}
Abstract class of a non\sphinxhyphen{}adaptive Factory.

This is initialized with a given batch of scaling factors ("scalars").
The "self.next" method trivially iterates over the elements of "scalars"
in a non\sphinxhyphen{}adaptive way.
Convergence is achieved when all the correpsonding expectation values have been measured.

Specific (non\sphinxhyphen{}adaptive) zero\sphinxhyphen{}noise extrapolation algorithms can be derived from this class by
overriding the "self.reduce" and (if necessary) the "\_\_init\_\_" method.
\index{is\_converged() (mitiq.factories.BatchedFactory method)@\spxentry{is\_converged()}\spxextra{mitiq.factories.BatchedFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.BatchedFactory.is_converged}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_converged}}}{}{{ $\rightarrow$ bool}}
Returns True if all needed expectation values have been computed, else False.

\end{fulllineitems}

\index{next() (mitiq.factories.BatchedFactory method)@\spxentry{next()}\spxextra{mitiq.factories.BatchedFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.BatchedFactory.next}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{next}}}{}{{ $\rightarrow$ float}}
Returns the next noise level to execute a circuit at.

\end{fulllineitems}


\end{fulllineitems}

\index{ExpFactory (class in mitiq.factories)@\spxentry{ExpFactory}\spxextra{class in mitiq.factories}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.ExpFactory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mitiq.factories.}}\sphinxbfcode{\sphinxupquote{ExpFactory}}}{\emph{scalars: Iterable{[}float{]}, asymptote: Optional{[}float{]} = None}}{}
Factory object implementing a zero\sphinxhyphen{}noise extrapolation algotrithm assuming an
exponential ansatz y(x) = a + b * exp(\sphinxhyphen{}c * x), with c \textgreater{} 0.

If the asymptotic value (y(x\sphinxhyphen{}\textgreater{}inf) = a) is known, a linear fit with respect
to z(x) := log{[}sing(b) (y(x) \sphinxhyphen{} a){]} is used.
Otherwise, a non\sphinxhyphen{}linear fit of y(x) is perfomed.
\index{reduce() (mitiq.factories.ExpFactory method)@\spxentry{reduce()}\spxextra{mitiq.factories.ExpFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.ExpFactory.reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduce}}}{}{{ $\rightarrow$ float}}
Returns the zero\sphinxhyphen{}noise limit, assuming an exponential ansatz:
y(x) = a + b * exp(\sphinxhyphen{}c * x), with c \textgreater{} 0.

\end{fulllineitems}


\end{fulllineitems}

\index{Factory (class in mitiq.factories)@\spxentry{Factory}\spxextra{class in mitiq.factories}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.Factory}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mitiq.factories.}}\sphinxbfcode{\sphinxupquote{Factory}}}
Abstract class designed to adaptively produce a new noise scaling parameter
based on a historical stack of previous noise scale parameters ("self.instack")
and previously estimated expectation values ("self.outstack").

Specific zero\sphinxhyphen{}noise extrapolation algorithms, adaptive or non\sphinxhyphen{}adaptive,
are derived from this class.
A Factory object is not supposed to directly perform any quantum computation,
only the classical results of quantum experiments are processed by it.
\index{is\_converged() (mitiq.factories.Factory method)@\spxentry{is\_converged()}\spxextra{mitiq.factories.Factory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.Factory.is_converged}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_converged}}}{}{{ $\rightarrow$ bool}}
Returns True if all needed expectation values have been computed, else False.

\end{fulllineitems}

\index{next() (mitiq.factories.Factory method)@\spxentry{next()}\spxextra{mitiq.factories.Factory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.Factory.next}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{next}}}{}{{ $\rightarrow$ float}}
Returns the next noise level to execute a circuit at.

\end{fulllineitems}

\index{push() (mitiq.factories.Factory method)@\spxentry{push()}\spxextra{mitiq.factories.Factory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.Factory.push}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{push}}}{\emph{instack\_val: float}, \emph{outstack\_val: float}}{{ $\rightarrow$ None}}
Appends "instack\_val" to "self.instack" and "outstack\_val" to "self.outstack".
Each time a new expectation value is computed this method should be used
to update the internal state of the Factory.

\end{fulllineitems}

\index{reduce() (mitiq.factories.Factory method)@\spxentry{reduce()}\spxextra{mitiq.factories.Factory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.Factory.reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduce}}}{}{{ $\rightarrow$ float}}
Returns the extrapolation to the zero\sphinxhyphen{}noise limit.

\end{fulllineitems}


\end{fulllineitems}

\index{LinearFactory (class in mitiq.factories)@\spxentry{LinearFactory}\spxextra{class in mitiq.factories}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.LinearFactory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mitiq.factories.}}\sphinxbfcode{\sphinxupquote{LinearFactory}}}{\emph{scalars: Iterable{[}float{]}}}{}
Factory object implementing a zero\sphinxhyphen{}noise extrapolation algotrithm based on a linear fit.
\index{reduce() (mitiq.factories.LinearFactory method)@\spxentry{reduce()}\spxextra{mitiq.factories.LinearFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.LinearFactory.reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduce}}}{}{{ $\rightarrow$ float}}
Determines, with a least squared method, the line of best fit
associated to the data points. The intercept is returned.

\end{fulllineitems}


\end{fulllineitems}

\index{PolyExpFactory (class in mitiq.factories)@\spxentry{PolyExpFactory}\spxextra{class in mitiq.factories}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.PolyExpFactory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mitiq.factories.}}\sphinxbfcode{\sphinxupquote{PolyExpFactory}}}{\emph{scalars: Iterable{[}float{]}, order: int, asymptote: Optional{[}float{]} = None}}{}
Factory object implementing a zero\sphinxhyphen{}noise extrapolation algotrithm assuming an
(almost) exponential ansatz with a non linear exponent, i.e.:

y(x) = a + s * exp(z(x)), where z(x) is a polynomial of a given order.

The parameter "s" is a sign variable which can be either 1 or \sphinxhyphen{}1, corresponding to
decreasing and increasing exponentials, respectively. The parameter "s" is
automatically deduced from the data.

If the asymptotic value (y(x\sphinxhyphen{}\textgreater{}inf) = a) is known, a linear fit with respect
to z(x) := log{[}s(y(x) \sphinxhyphen{} a){]} is used.
Otherwise, a non\sphinxhyphen{}linear fit of y(x) is perfomed.
\index{reduce() (mitiq.factories.PolyExpFactory method)@\spxentry{reduce()}\spxextra{mitiq.factories.PolyExpFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.PolyExpFactory.reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduce}}}{}{{ $\rightarrow$ float}}
Returns the zero\sphinxhyphen{}noise limit, assuming an exponential ansatz:
y(x) = a + s * exp(z(x)), where z(x) is a polynomial of a given order.
The parameter "s" is a sign variable which can be either 1 or \sphinxhyphen{}1, corresponding to
decreasing and increasing exponentials, respectively. The parameter "s" is
automatically deduced from the data.
It is also assumed that z(x\sphinxhyphen{}\sphinxhyphen{}\textgreater{}inf)=\sphinxhyphen{}inf, such that y(x\sphinxhyphen{}\sphinxhyphen{}\textgreater{}inf)\sphinxhyphen{}\sphinxhyphen{}\textgreater{}a.

\end{fulllineitems}

\index{static\_reduce() (mitiq.factories.PolyExpFactory static method)@\spxentry{static\_reduce()}\spxextra{mitiq.factories.PolyExpFactory static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.PolyExpFactory.static_reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{static\_reduce}}}{\emph{instack: List{[}float{]}, outstack: List{[}float{]}, asymptote: Optional{[}float{]}, order: int, eps: float = 1e\sphinxhyphen{}09}}{{ $\rightarrow$ float}}
Determines the zero\sphinxhyphen{}noise limit, assuming an exponential ansatz:
y(x) = a + s * exp(z(x)), where z(x) is a polynomial of a given order.

The parameter "s" is a sign variable which can be either 1 or \sphinxhyphen{}1, corresponding to
decreasing and increasing exponentials, respectively. The parameter "s" is
automatically deduced from the data.

It is also assumed that z(x\sphinxhyphen{}\sphinxhyphen{}\textgreater{}inf)=\sphinxhyphen{}inf, such that y(x\sphinxhyphen{}\sphinxhyphen{}\textgreater{}inf)\sphinxhyphen{}\sphinxhyphen{}\textgreater{}a.

If asymptote is None, the ansatz y(x) is fitted with a non\sphinxhyphen{}linear optimization.
Otherwise, a linear fit with respect to z(x) := log(sign * (y(x) \sphinxhyphen{} asymptote))
is performed.

This static method is equivalent to the "self.reduce" method of PolyExpFactory,
but can be called also by other factories which are particular cases of PolyExpFactory,
e.g., ExpFactory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{instack}} \sphinxhyphen{}\sphinxhyphen{} x data values.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outstack}} \sphinxhyphen{}\sphinxhyphen{} y data values.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{asymptote}} \sphinxhyphen{}\sphinxhyphen{} y(x\sphinxhyphen{}\textgreater{}inf).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} \sphinxhyphen{}\sphinxhyphen{} extrapolation order.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eps}} \sphinxhyphen{}\sphinxhyphen{} epsilon to regularize log(sign (instack \sphinxhyphen{} asymptote)) when
the argument is to close to zero or negative.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PolyFactory (class in mitiq.factories)@\spxentry{PolyFactory}\spxextra{class in mitiq.factories}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.PolyFactory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mitiq.factories.}}\sphinxbfcode{\sphinxupquote{PolyFactory}}}{\emph{scalars: Iterable{[}float{]}, order: int}}{}
Factory object implementing a zero\sphinxhyphen{}noise extrapolation algotrithm based on a polynomial fit.
Note: RichardsonFactory and LinearFactory are special cases of PolyFactory.
\index{reduce() (mitiq.factories.PolyFactory method)@\spxentry{reduce()}\spxextra{mitiq.factories.PolyFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.PolyFactory.reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduce}}}{}{{ $\rightarrow$ float}}
Determines with a least squared method, the polynomial of degree equal to "self.order"
which optimally fits the input data. The zero\sphinxhyphen{}noise limit is returned.

\end{fulllineitems}

\index{static\_reduce() (mitiq.factories.PolyFactory static method)@\spxentry{static\_reduce()}\spxextra{mitiq.factories.PolyFactory static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.PolyFactory.static_reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{static\_reduce}}}{\emph{instack: List{[}float{]}, outstack: List{[}float{]}, order: int}}{{ $\rightarrow$ float}}
Determines with a least squared method, the polynomial of degree equal to \textquotesingle{}order\textquotesingle{}
which optimally fits the input data. The zero\sphinxhyphen{}noise limit is returned.

This static method is equivalent to the "self.reduce" method of PolyFactory, but
can be called also by other factories which are particular cases of PolyFactory,
e.g., LinearFactory and RichardsonFactory.

\end{fulllineitems}


\end{fulllineitems}

\index{RichardsonFactory (class in mitiq.factories)@\spxentry{RichardsonFactory}\spxextra{class in mitiq.factories}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.RichardsonFactory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mitiq.factories.}}\sphinxbfcode{\sphinxupquote{RichardsonFactory}}}{\emph{scalars: Iterable{[}float{]}}}{}
Factory object implementing Richardson\textquotesingle{}s extrapolation.
\index{reduce() (mitiq.factories.RichardsonFactory method)@\spxentry{reduce()}\spxextra{mitiq.factories.RichardsonFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.factories.RichardsonFactory.reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduce}}}{}{{ $\rightarrow$ float}}
Returns the Richardson\textquotesingle{}s extrapolation to the zero\sphinxhyphen{}noise limit.

\end{fulllineitems}


\end{fulllineitems}



\section{Zero Noise Extrapolation}
\label{\detokenize{index:module-mitiq.zne}}\label{\detokenize{index:zero-noise-extrapolation}}\index{mitiq.zne (module)@\spxentry{mitiq.zne}\spxextra{module}}
Zero\sphinxhyphen{}noise extrapolation tools.
\index{execute\_with\_zne() (in module mitiq.zne)@\spxentry{execute\_with\_zne()}\spxextra{in module mitiq.zne}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.zne.execute_with_zne}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mitiq.zne.}}\sphinxbfcode{\sphinxupquote{execute\_with\_zne}}}{\emph{qp: Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}, executor: Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]}, float{]}, fac: mitiq.factories.Factory = None, scale\_noise: Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}, float{]}, Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]} = None}}{{ $\rightarrow$ Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]}, float{]}}}
Takes as input a quantum circuit and returns the associated expectation value
evaluated with error mitigation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{qp}} \sphinxhyphen{}\sphinxhyphen{} Quantum circuit to execute with error mitigation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{executor}} \sphinxhyphen{}\sphinxhyphen{} Function executing a circuit and producing an expectation value
(without error mitigation).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fac}} \sphinxhyphen{}\sphinxhyphen{} Factory object determining the zero\sphinxhyphen{}noise extrapolation algorithm.
If not specified, LinearFactory({[}1.0, 2.0{]}) will be used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_noise}} \sphinxhyphen{}\sphinxhyphen{} Function for scaling the noise of a quantum circuit.
If not specified, a default method will be used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mitigate\_executor() (in module mitiq.zne)@\spxentry{mitigate\_executor()}\spxextra{in module mitiq.zne}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.zne.mitigate_executor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mitiq.zne.}}\sphinxbfcode{\sphinxupquote{mitigate\_executor}}}{\emph{executor: Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]}, float{]}, fac: mitiq.factories.Factory = None, scale\_noise: Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}, float{]}, Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]} = None}}{{ $\rightarrow$ Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]}, float{]}}}
Takes as input a generic function ("executor"), difined by the user, which executes a circuit
with an arbitrary backend and produces an expectation value.

Returns an error\sphinxhyphen{}mitigated version of the input "executor", having the same signature and
automatically performing zero\sphinxhyphen{}noise extrapolation at each call.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{executor}} \sphinxhyphen{}\sphinxhyphen{} Function (to be mitigated) executing a circuit and returning an expectation value.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fac}} \sphinxhyphen{}\sphinxhyphen{} Factory object determining the zero\sphinxhyphen{}noise extrapolation algorithm.
If not specified, LinearFactory({[}1.0, 2.0{]}) is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_noise}} \sphinxhyphen{}\sphinxhyphen{} Function for scaling the noise of a quantum circuit.
If not specified, a default method is used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{qrun\_factory() (in module mitiq.zne)@\spxentry{qrun\_factory()}\spxextra{in module mitiq.zne}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.zne.qrun_factory}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mitiq.zne.}}\sphinxbfcode{\sphinxupquote{qrun\_factory}}}{\emph{fac: mitiq.factories.Factory, qp: Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}, executor: Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]}, float{]}, scale\_noise: Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}, float{]}, Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]}}}{{ $\rightarrow$ None}}
Runs the factory until convergence executing quantum circuits with different noise levels.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fac}} \sphinxhyphen{}\sphinxhyphen{} Factory object to run until convergence.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{qp}} \sphinxhyphen{}\sphinxhyphen{} Circuit to mitigate.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{executor}} \sphinxhyphen{}\sphinxhyphen{} Function which executes a circuit and returns an expectation value.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_noise}} \sphinxhyphen{}\sphinxhyphen{} Function which scales the noise level of a quantum circuit.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_factory() (in module mitiq.zne)@\spxentry{run\_factory()}\spxextra{in module mitiq.zne}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.zne.run_factory}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mitiq.zne.}}\sphinxbfcode{\sphinxupquote{run\_factory}}}{\emph{fac: mitiq.factories.Factory, noise\_to\_expval: Callable{[}{[}float{]}, float{]}, max\_iterations: int = 100}}{{ $\rightarrow$ None}}
Runs a factory until convergence (or until the number of iterations reach "max\_iterations").
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fac}} \sphinxhyphen{}\sphinxhyphen{} Instance of Factory object to be run.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noise\_to\_expval}} \sphinxhyphen{}\sphinxhyphen{} Function mapping noise scale values to expectation vales.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_iterations}} \sphinxhyphen{}\sphinxhyphen{} Maximum number of iterations (optional). Default value is 100.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{zne\_decorator() (in module mitiq.zne)@\spxentry{zne\_decorator()}\spxextra{in module mitiq.zne}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:mitiq.zne.zne_decorator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mitiq.zne.}}\sphinxbfcode{\sphinxupquote{zne\_decorator}}}{\emph{fac: mitiq.factories.Factory = None, scale\_noise: Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}, float{]}, Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]} = None}}{{ $\rightarrow$ Callable{[}{[}Union{[}qiskit.circuit.quantumcircuit.QuantumCircuit, pyquil.quil.Program{]}{]}, float{]}}}
Decorator which automatically adds error mitigation to any circuit\sphinxhyphen{}executor function
defined by the user.

It is supposed to be applied to any function which executes a quantum circuit
with an arbitrary backend and produces an expectation value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fac}} \sphinxhyphen{}\sphinxhyphen{} Factory object determining the zero\sphinxhyphen{}noise extrapolation algorithm.
If not specified, LinearFactory({[}1.0, 2.0{]}) will be used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_noise}} \sphinxhyphen{}\sphinxhyphen{} Function for scaling the noise of a quantum circuit.
If not specified, a default method will be used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{mitiq}\sphinxstyleindexpageref{index:\detokenize{module-mitiq}}
\item\relax\sphinxstyleindexentry{mitiq.factories}\sphinxstyleindexpageref{index:\detokenize{module-mitiq.factories}}
\item\relax\sphinxstyleindexentry{mitiq.zne}\sphinxstyleindexpageref{index:\detokenize{module-mitiq.zne}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}