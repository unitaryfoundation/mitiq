---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.14.1
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Digital dynamical decoupling (DDD) with Mirror Circuits

In this notebook DDD is applied to improve the success rate of the computation. 
In DDD, sequences of gates are applied to slack windows, i.e. single-qubit idle windows, in a quantum circuit. 
Applying such sequences can reduce the coupling between the qubits and the environment, mitigating the effects of noise. 
For more information on DDD, see the section [DDD section of the user guide](../guide/ddd.myst).

## Setup

We begin by importing the relevant modules and libraries that we will require
for the rest of this tutorial.

```{code-cell} ipython3
import functools
from typing import List, Tuple, Union

# Plotting imports.
import matplotlib.pyplot as plt

plt.rcParams.update({"font.family": "serif", "font.size": 15})
%matplotlib inline

# Third-party imports.
import cirq

import networkx as nx
import numpy as np

# Mitiq imports.
from mitiq import benchmarks, ddd
```

## Define parameters

```{code-cell} ipython3
# Random seed for circuit generation.
seed: int = 1

# Total number of shots to use.
shots: int = 1000

# Qubits to use on the experiment.
qubits: List[int] = [0, 1, 2]

# Average results over this many trials (circuit instances) at each depth.
trials: int = 3

# Clifford depths.
depths: List[int] = [1, 5, 9]
```

We also define a graph representation of our qubits and assume a line topology.

```{code-cell} ipython3
# Assume chain-like connectivity
computer = nx.Graph()
computer.add_edges_from([(0, 1), (1, 2)])
nx.draw(computer, with_labels=True)

# Add reversed edges to computer graph.
# This is important to represent CNOT gates with target and control reversed.
computer = nx.to_directed(computer)
```

## Define the circuit

We use mirror circuits to benchmark the performance of the device.
Mirror circuits, introduced in
*Proctor et al. arXiv (2021)* {cite}`Proctor_2021_NatPhys` ([arXiv:2008.11294](https://arxiv.org/abs/2008.11294)),
are designed such that only one bitstring should be sampled. 
When run on a device, any other measured bitstrings are due to noise.
The frequency of the correct bitstring is our target metric.

> Note: Mirror circuits build on Loschmidt echo circuits - i.e., circuits of the form $U U^\dagger$ for some unitary $U$.
Loschmidt echo circuits are good benchmarks but have shortcomings - e.g., they are unable to detect coherent errors.
Mirror circuits add new features to account for these shortcomings. 
For more background, see [arXiv:2008.11294](https://arxiv.org/abs/2008.11294).

To define a mirror circuit, we need the device graph. 
We will use a subgraph of the device, and our first step is picking a subgraph with good qubits.


### Generate mirror circuit

Now that we have the device (sub)graph, we can generate a mirror circuit and the bitstring it should sample as follows.

```{code-cell} ipython3
def get_circuit(depth: int, seed: int) -> Tuple[cirq.Circuit, str]:
    circuit, correct_bitstring = benchmarks.generate_mirror_circuit(
        nlayers=depth,
        two_qubit_gate_prob=1.0,
        connectivity_graph=computer,
        two_qubit_gate_name="CNOT",
        seed=seed,
        return_type="cirq",
    )
    return circuit, correct_bitstring
```

### Helper methods

It will be useful later to us to have a number of utility functions for counting CNOT gates and operations.

```{code-cell} ipython3
def get_num_cnot_count(circuit: cirq.Circuit) -> int:
    """Determine number of cnot gates in a given `Circuit` object."""
    # Count CNOT gates for `cirq`-type circuit objects:
    num_cnots: int = 0
    for instruction in circuit.all_operations():
        if isinstance(instruction, cirq.CXPowGate):
            num_cnots += 1
    return num_cnots


def get_oneq_count(circuit: cirq.Circuit) -> int:
    return len(list(circuit.all_operations())) - get_num_cnot_count(circuit)
```

## Define the executor

Now that we have a circuit, we define the `execute` function which inputs a circuit and returns an expectation value - here, the
frequency of sampling the correct bitstring.

```{code-cell} ipython3
def execute(
    circuits: Union[cirq.Circuit, List[cirq.Circuit]],
    shots: int,
    correct_bitstring: str,
    is_noisy: bool = True,
) -> List[float]:
    """Executes the input circuit(s) and returns ⟨A⟩, where
    A = |correct_bitstring⟩⟨correct_bitstring| for each circuit.
    """
    if not isinstance(circuits, list):
        circuits = [circuits]

    # Store all circuits to run in list to be returned.
    to_run: List[cirq.Circuit] = []

    # Compile circuits to appropriate gateset.
    for circuit in circuits:
        circuit_to_run = circuit.copy()
        if is_noisy:
            to_run.append(circuit_to_run.with_noise(cirq.amplitude_damp(0.05)))
        else:
            to_run.append(circuit_to_run)

    backend = cirq.Simulator()

    # Process each job.
    results: List[float] = []
    for circ_to_run in to_run:
        counts = 0
        for _ in range(shots):
            result = backend.run(
                circ_to_run + cirq.measure(*sorted(circuit.all_qubits()))
            )
            bitstring = list(result.measurements.values())[0][0].tolist()
            if bitstring == correct_bitstring:
                counts += 1
        results.append(counts / shots)

    return results
```

## Select the DDD sequences to be applied
We now import a DDD _rule_ from Mitiq, i. e., a function that generates DDD sequences of different length.
In this example, with simulated amplitude damping noise, we opt for YY sequences (pairs of Pauli Y operations).

```{code-cell} ipython3
from mitiq import ddd

rule = ddd.rules.yy
```

## Running the experiment

```{code-cell} ipython3
:tags: ["skip-execution"]
cnot_counts, oneq_counts = [], []
true_values, noisy_values = [], []
ddd_values = []

noise_scaled_expectation_values = []

for depth in depths:
    print("Status: On depth", depth, end="\n\n")

    cnot_depth_counts, oneq_depth_counts = [], []
    true_depth_values, noisy_depth_values = [], []
    ddd_depth_values = []

    noise_scaled_expectation_depth_values = []

    for trial in range(trials):
        # Local seed is calculated in this way to ensure that we don't get repeat values in loop.
        local_seed = 10**6 * depth + 10**3 * seed + trial

        circuit, correct_bitstring = get_circuit(depth, local_seed)

        (true_value,) = execute(circuit, shots, correct_bitstring, is_noisy=False)
        (noisy_value,) = execute(circuit, shots, correct_bitstring, is_noisy=True)

        ddd_executor = functools.partial(
            execute,
            shots=shots,
            correct_bitstring=correct_bitstring,
        )

        ddd_value = ddd.execute_with_ddd(
            circuit, ddd_executor, rule=rule, num_trials = 100,
        )

        ddd_depth_values.append(ddd_value)

        cnot_depth_counts.append(get_num_cnot_count(circuit))
        oneq_depth_counts.append(get_oneq_count(circuit))

        true_depth_values.append(true_value)
        noisy_depth_values.append(noisy_value)

    cnot_counts.append(cnot_depth_counts)
    oneq_counts.append(oneq_depth_counts)

    true_values.append(true_depth_values)
    noisy_values.append(noisy_depth_values)

    noise_scaled_expectation_values.append(noise_scaled_expectation_depth_values)

    ddd_values.append(ddd_depth_values)
```

Now we can visualize the results.

```{code-cell} ipython3
:tags: ["skip-execution"]
avg_true_values = np.average(true_values, axis=1)
avg_noisy_values = np.average(noisy_values, axis=1)

std_true_values = np.std(true_values, axis=1, ddof=1)
std_noisy_values = np.std(noisy_values, axis=1, ddof=1)

avg_ddd_values = np.average(ddd_values, axis=1)
std_ddd_values = np.std(ddd_values, axis=1, ddof=1)

plt.figure(figsize=(9, 5))

plt.plot(depths, avg_true_values, "--", label="True", lw=2)
eb = plt.errorbar(depths, avg_noisy_values, yerr=std_noisy_values, label="Raw", ls="-.")
eb[-1][0].set_linestyle("-.")
plt.errorbar(depths, avg_ddd_values, yerr=std_ddd_values, label="DDD")

plt.title(
    f"""Simulator with mirror circuits using ddd \nqubits {qubits}, {trials} trials."""
)
plt.xlabel("Depth")
plt.ylabel("Expectation value")
_ = plt.legend()
```

```{figure} ../_thumbnails/ddd-tutorial.png
---

name: ddd_mirror_circuit_comparison
---
The figure is a plot of the expectation values obtained from simulating mirror circuits with amplitude damping noise and applying DDD.
```


We can see that DDD on average improves the expectation value at depths above 3.
Note that the size of the error bars represents the standard deviation of the noisy values (for the "Raw" line) and the standard
deviation of the DDD values (for the "DDD" line).
