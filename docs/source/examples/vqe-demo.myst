---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: '0.8'
    jupytext_version: '1.4.1'
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Variational Quantum Eigensolver improved with Mitiq
In this example we investigate how Mitiq can help reduce errors
and improve convergence of a simple VQE problem executed
on a simulated noisy backend.


The pyQuil VQE example shown here is adapted from
https://grove-docs.readthedocs.io/en/latest/vqe.html#, 
and the VQE function in Grove.

```{code-cell}
import numpy as np
from pyquil import get_qc, Program
from pyquil.gates import RX, S, T, Z, CNOT, MEASURE
from typing import List, Union
from collections import Counter
import mitiq
from mitiq import zne
from scipy import optimize
from pyquil.paulis import PauliTerm, PauliSum, sZ
from pyquil.noise import pauli_kraus_map
from matplotlib import pyplot as plt
```
+++

Use the get_qc command to initialize the simulated noisy device where the PyQuil program will run

```{code-cell}
# initialize quantum device
qc = get_qc("2q-noisy-qvm")
```

+++

Example ansatz

```{code-cell}

def ansatz():
    program = Program()
    theta = program.declare("theta", memory_type="REAL")
    program += RX(theta, 0)
    program += T(0)
    program += CNOT(1,0)
    program += S(0)
    program += Z(0)
    return program
```

+++

 Hamiltonian in this example is just sigma_z on the zeroth qubit
```{code-cell}
program = ansatz()
hamiltonian = sZ(0)
samples = 4000
pauli_sum = PauliSum([hamiltonian])

# apply the Hamiltonian
for j, term in enumerate(pauli_sum.terms):
    meas_basis_change = Program()
    marked_qubits = []
    for index, gate in term:
        marked_qubits.append(index)
        if gate == 'X':
            meas_basis_change.inst(RY(-np.pi / 2, index))
        elif gate == 'Y':
            meas_basis_change.inst(RX(np.pi / 2, index))
        program += meas_basis_change
    # Memory declaration for readout "ro"
    ro = program.declare('ro', 'BIT', max(marked_qubits) + 1)
    program += [MEASURE(qubit, r)
        for qubit, r in zip(list(range(max(marked_qubits) + 1)), ro)]
program.wrap_in_numshots_loop(samples)
quil_prog = qc.compiler.quil_to_native_quil(program, protoquil=True)
```

+++

Set up the VQE: 

Compute expectation value of the Hamiltonian over the over the distribution generated from the quantum program

```{code-cell}
def expectation(thetas, qc, ro, samples: int,
                pauli_sum: Union[PauliSum, PauliTerm, np.ndarray],
                pyquil_prog: Program) -> float:
    """
    Compute the expectation value of pauli_sum over the distribution generated from pyquil_prog.

    :param pyquil_prog: The state preparation Program to calculate the expectation value of.
    :param pauli_sum: PauliSum representing the operator of which to calculate the expectation
            value
    :param samples: The number of samples used to calculate the expectation value.
    :return: A float representing the expectation value of pauli_sum given the distribution
            generated from quil_prog.
        """
    expectation = 0.0
    pauli_sum = PauliSum([pauli_sum])
    for j, term in enumerate(pauli_sum.terms):
        qubits_to_measure = []
        for index, gate in term:
            qubits_to_measure.append(index)    
            meas_outcome = expectation_from_sampling(
                            thetas, pyquil_prog, qubits_to_measure, 
                            qc, samples)
            expectation += term.coefficient * meas_outcome
    return expectation.real
```

+++


Calculate the expectation value of the Zi operator at marked_qubits

```{code-cell}
def expectation_from_sampling(thetas, executable: Program,
                              marked_qubits: List[int], qc,
                              samples: int) -> float:
    """

    Given a wavefunction, this calculates the expectation value of the Zi
    operator where i ranges over all the qubits given in marked_qubits.

    :param pyquil_program: pyQuil program generating some state
    :param marked_qubits: The qubits within the support of the Z pauli
                          operator whose expectation value is being calculated
    :param qc: A QuantumComputer object.
    :param samples: Number of bitstrings collected to calculate expectation
                    from sampling.
    :returns: The expectation value as a float.
    """
    bitstring_samples = qc.run(executable, memory_map={'theta': thetas})
    bitstring_tuples = list(map(tuple, bitstring_samples))

    freq = Counter(bitstring_tuples)

    # perform weighted average
    exp_val = 0
    for bitstring, count in freq.items():
        bitstring_int = int("".join([str(x) for x in bitstring[::-1]]), 2)
        if parity_even_p(bitstring_int, marked_qubits):
            exp_val += float(count) / samples
        else:
            exp_val -= float(count) / samples
    return exp_val
```
+++

Calculate the parity of elements at indexes in marked_qubits

```{code-cell}
def parity_even_p(state, marked_qubits):
    """
    Parity is relative to the binary representation of the integer state.

    :param state: The wavefunction index that corresponds to this state.
    :param marked_qubits: The indexes to be considered in the parity sum.
    :returns: A boolean corresponding to the parity.
    """
    mask = 0
    for q in marked_qubits:
        mask |= 1 << q
    return bin(mask & state).count("1") % 2 == 0
```

+++


Scan over the parameter theta and plot energy expecation, without mitigation 
```{code-cell}
thetas = np.linspace(0, 2 * np.pi, 101)
results = []
 
for theta in thetas:
    results.append(expectation(theta, qc, ro, samples, hamiltonian, quil_prog))

_ = plt.figure(1)
_ = plt.plot(thetas, results, 'o-')
_ = plt.xlabel(r'$\theta$', fontsize=18)
_ = plt.ylabel(r'$\langle \Psi(\theta) | Z | \Psi(\theta) \rangle$', fontsize=18)    
_ = plt.title('Noisy Energy Landscape')
plt.show()
```

+++


Run VQE routine without noise mitigation

```{code-cell}
init_angle = [1.0]
# use the Nelder-Mead method in `scipy minimizer` to find the minimimum of the expectation value
res = optimize.minimize(expectation, init_angle, args=(qc, ro, samples, hamiltonian, quil_prog),    
                        method='Nelder-Mead', options={ 'xatol': 1.0e-3, 'fatol': 1.0e-2})
print(res)
```

+++


Now introduce noise mitigation technique Zero Noise Extrapolation

Create new objective function to calculate expecation value w/ noise mitigation

```{code-cell}
def mitigated_expectation(thetas, qc, ro, samples, 
                          pauli_sum, executable: Program, factory) -> float:
    mitigated_exp =  zne.execute_with_zne(executable, lambda p: expectation(
                        thetas, qc, ro, samples, pauli_sum, p), factory)
    return mitigated_exp
```

+++

```{code-cell}
# here we use a linear extrapolation technique 
fac = mitiq.zne.inference.LinearFactory(scale_factors=[1.0, 8.0])
```

+++

Scan over the parameter theta and plot energy expecation with noise mitigation 

```{code-cell}
results_zne = []
for theta in thetas:
    results_zne.append(
        mitigated_expectation(theta, qc, ro, samples, hamiltonian, quil_prog, fac)
    )

_ = plt.figure(2)
_ = plt.plot(thetas, results_zne, 'o-')
_ = plt.xlabel(r'$\theta$', fontsize=18)
_ = plt.ylabel(r'$\langle \Psi(\theta) | Z | \Psi(\theta) \rangle$', fontsize=18)    
_ = plt.title('Mitigated Energy Landscape')
plt.show()
```

+++

Run VQE routine with noise mitigation

```{code-cell}
res_zne = optimize.minimize(mitigated_expectation, init_angle, args=(
                             qc, ro, samples, hamiltonian, quil_prog, fac), 
                             method='Nelder-Mead', options={ 
                            'xatol': 1.0e-3, 'fatol': 1.0e-2})
print(res_zne)
```



## References
[1] [VQE tutorial in PyQuil.]
https://grove-docs.readthedocs.io/en/latest/vqe.html#

[2] Rigetti Computing (2018) Grove (Version 1.7.0) [Source code].https://github.com/rigetti/grove


+++

display information about Mitiq, packages, and Python version/platform
```{code-cell}
mitiq.about()
```
