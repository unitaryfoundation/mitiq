---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.10.3
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Variational Quantum Eigensolver improved with Mitiq
In this example we investigate how Mitiq can help reduce errors
and improve convergence of a simple VQE problem executed
on a simulated noisy backend.


The pyQuil VQE example shown here is adapted from
https://grove-docs.readthedocs.io/en/latest/vqe.html#, 
and the VQE function in Grove.

```{code-cell} ipython3
import numpy as np
from pyquil import get_qc, Program
from pyquil.gates import RX, RY, S, T, Z, CNOT, MEASURE
from pyquil.paulis import PauliTerm, PauliSum, sZ
from pyquil.noise import pauli_kraus_map, append_kraus_to_gate
from grove.pyvqe.vqe import parity_even_p
from typing import List, Union
from collections import Counter
from matplotlib import pyplot as plt
from scipy import optimize
import mitiq
from mitiq import zne
from mitiq.zne.scaling.folding import fold_gates_from_right
```

Use the get_qc command to initialize the simulated noisy device where the PyQuil program will run

```{code-cell} ipython3
# initialize the quantum device
qc = get_qc("2q-qvm")
```

Example ansatz

```{code-cell} ipython3
program = Program()
theta = program.declare("theta", memory_type="REAL")
program += RX(theta, 0)
program += T(0)
program += CNOT(1, 0)
program += S(0)
program += Z(0)
```

Simulate depolarizing noise on the static gates

```{code-cell} ipython3
def add_noise_to_circuit(quil_prog):
    prob = 0.8
    num_qubits = 1
    d = 4 ** num_qubits
    d_sq = d ** 2
    kraus_list = [(1 - prob) / d] * d
    kraus_list[0] += prob
    kraus_ops = pauli_kraus_map(kraus_list)
    k_list = [(1 - prob) / d_sq] * d_sq
    k_list[0] += prob
    k_ops = pauli_kraus_map(k_list)
    T_gate = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]])
    CN_gate = np.block(
        [[np.eye(2), np.zeros((2, 2))], [np.zeros((2, 2)), np.flip(np.eye(2), 1)]]
    )
    S_gate = np.array([[1, 0], [0, 1j]])
    Z_gate = np.array([[1, 0], [0, -1]])
    quil_prog.define_noisy_gate("T", [0], append_kraus_to_gate(kraus_ops, T_gate))
    quil_prog.define_noisy_gate("CNOT", [1, 0], append_kraus_to_gate(k_ops, CN_gate))
    quil_prog.define_noisy_gate("S", [0], append_kraus_to_gate(kraus_ops, S_gate))
    quil_prog.define_noisy_gate("Z", [0], append_kraus_to_gate(kraus_ops, Z_gate))
    return quil_prog
```

 Hamiltonian in this example is just sigma_z on the zeroth qubit

```{code-cell} ipython3
hamiltonian = sZ(0)
pauli_sum = PauliSum([hamiltonian])

# apply the Hamiltonian
for j, term in enumerate(pauli_sum.terms):
    meas_basis_change = Program()
    marked_qubits = []
    for index, gate in term:
        marked_qubits.append(index)
        if gate == "X":
            meas_basis_change.inst(RY(-np.pi / 2, index))
        elif gate == "Y":
            meas_basis_change.inst(RX(np.pi / 2, index))
        program += meas_basis_change
    # Memory declaration for readout "ro"
    ro = program.declare("ro", "BIT", max(marked_qubits) + 1)

samples = 3000
program.wrap_in_numshots_loop(samples)
```

Set up the VQE: 

Compute expectation value of the Hamiltonian over the over the distribution generated from the quantum program

```{code-cell} ipython3
def executor(
    thetas,
    qc,
    ro,
    samples: int,
    pauli_sum: Union[PauliSum, PauliTerm, np.ndarray],
    pyquil_prog: Program,
) -> float:
    """
    Compute the expectation value of pauli_sum over the distribution generated from pyquil_prog.

    :param pyquil_prog: The state preparation Program to calculate the expectation value of.
    :param pauli_sum: PauliSum representing the operator of which to calculate the expectation
            value
    :param samples: The number of samples used to calculate the expectation value.
    :param qc: The QuantumComputer object.
    :return: A float representing the expectation value of pauli_sum given the distribution
            generated from pyquil_prog.
    """
    # # Simulate depolarizing noise.
    # # Requires use of custom gates which cannot be folded and must be defined in executor fn
    noisy = pyquil_prog.copy()
    noisy += [
        MEASURE(qubit, r) for qubit, r in zip(list(range(max(marked_qubits) + 1)), ro)
    ]
    noisy = add_noise_to_circuit(noisy)
    expectation = 0.0
    pauli_sum = PauliSum([pauli_sum])
    for j, term in enumerate(pauli_sum.terms):
        qubits_to_measure = []
        for index, gate in term:
            qubits_to_measure.append(index)
            meas_outcome = expectation_from_sampling(
                thetas, noisy, qubits_to_measure, qc, samples
            )
            expectation += term.coefficient * meas_outcome
    return expectation.real
```

Calculate the expectation value of the Zi operator at marked_qubits

```{code-cell} ipython3
def expectation_from_sampling(
    thetas, executable: Program, marked_qubits: List[int], qc, samples: int
) -> float:
    """

    Given a wavefunctions, this calculates the expectation value of the Zi
    operator where i ranges over all the qubits given in marked_qubits.

    :param pyquil_program: pyQuil program generating some state
    :param marked_qubits: The qubits within the support of the Z pauli
                          operator whose expectation value is being calculated
    :param qc: A QuantumComputer object.
    :param samples: Number of bitstrings collected to calculate expectation
                    from sampling.
    :returns: The expectation value as a float.
    """
    bitstring_samples = qc.run(executable, memory_map={"theta": thetas})
    bitstring_tuples = list(map(tuple, bitstring_samples))

    freq = Counter(bitstring_tuples)

    # perform weighted average
    exp_val = 0
    for bitstring, count in freq.items():
        bitstring_int = int("".join([str(x) for x in bitstring[::-1]]), 2)
        if parity_even_p(bitstring_int, marked_qubits):
            exp_val += float(count) / samples
        else:
            exp_val -= float(count) / samples
    return exp_val
```

Scan over the parameter theta and plot energy expecation, without mitigation

```{code-cell} ipython3
thetas = np.linspace(0, 2 * np.pi, 51)
results = []

for theta in thetas:
    results.append(executor(theta, qc, ro, samples, hamiltonian, program))
```

Run VQE routine without noise mitigation

```{code-cell} ipython3
init_angle = [3.0]
# use the Nelder-Mead method in `scipy minimizer` to find the minimimum of the expectation value
res = optimize.minimize(
    executor,
    init_angle,
    args=(qc, ro, samples, hamiltonian, program),
    method="Nelder-Mead",
    options={"xatol": 1.0e-3, "fatol": 1.0e-2},
)
print(res)
```

Now introduce noise mitigation technique Zero Noise Extrapolation

Create new objective function to calculate expecation value w/ noise mitigation

```{code-cell} ipython3
def mitigated_expectation(
    thetas, qc, ro, samples, pauli_sum, executable: Program, factory
) -> float:
    mitigated_exp = zne.execute_with_zne(
        executable,
        lambda p: executor(thetas, qc, ro, samples, pauli_sum, p),
        factory,
        fold_gates_from_right,
    )
    return mitigated_exp
```

```{code-cell} ipython3
# here we use a linear extrapolation technique
fac = mitiq.zne.inference.LinearFactory(scale_factors=[1.0, 3.0])
```

Scan over the parameter theta and plot energy expecation with noise mitigation

```{code-cell} ipython3
results_zne = []
for theta in thetas:
    results_zne.append(
        mitigated_expectation(theta, qc, ro, samples, hamiltonian, program, fac)
    )

_ = plt.figure()
_ = plt.plot(thetas, results, "o-", label="Noisy landscape")
_ = plt.plot(thetas, results_zne, "o-", label="Mitigated landscape")
_ = plt.xlabel(r"$\theta$", fontsize=18)
_ = plt.ylabel(r"$\langle \Psi(\theta) | Z | \Psi(\theta) \rangle$", fontsize=18)
_ = plt.title("Mitigated Energy Landscape")
plt.show()
```

Run VQE routine with noise mitigation

```{code-cell} ipython3
res_zne = optimize.minimize(
    mitigated_expectation,
    init_angle,
    args=(qc, ro, samples, hamiltonian, program, fac),
    method="Nelder-Mead",
    options={"xatol": 1.0e-3, "fatol": 1.0e-2},
)
print(res_zne)
```

## References
[1] [VQE tutorial in PyQuil.]
https://grove-docs.readthedocs.io/en/latest/vqe.html#

[2] Rigetti Computing (2018) Grove (Version 1.7.0) [Source code].https://github.com/rigetti/grove

+++

display information about Mitiq, packages, and Python version/platform

```{code-cell} ipython3
mitiq.about()
```
