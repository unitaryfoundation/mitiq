---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.1
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# What happens when I use PT?

The workflow of Pauli Twirling (PT) in Mitiq is represented in the figure below.

```{figure} ../img/pt_workflow.svg
---
width: 700px
name: pt-workflow-overview
---
Workflow of the PT technique in Mitiq, detailed in the [What happens when I use PT?](pt-4-low-level.md) section.
```

- The user provides a `QPROGRAM`, (i.e. a quantum circuit defined via any of the supported [frontends](frontends-backends.md)).
- Mitiq modifies the input circuit with the insertion of PT gates on noisy operations.
- The modified circuit is executed via a user-defined [Executor](executors.md).
- The error mitigated expectation value is returned to the user.

With respect to the workflows of other error-mitigation techniques (e.g. [ZNE](zne-4-low-level.md) or [PEC](pec-4-low-level.md)),
PT involves the generation and the execution of a _single_ modified circuit.
For this reason, there is no need to combine the results of multiple circuits and the final inference step which is necessary for other 
techniques is instead trivial for PT.

```{note}
When setting the `num_trials` option to a value larger than one, multiple circuits are actually generated by Mitiq and 
the associated results are averaged to obtain the final expectation value. This more general case is not shown in the figure since
it can be considered as an average of independent single-circuit workflows.
```

As shown in [How do I use PT?](pt-1-intro.md), the function {func}`.execute_with_pt()` applies PT behind the scenes 
and directly returns the error-mitigated expectation value.
In the next sections instead, we show how one can apply PT at a lower level, i.e., by:

- Detecting CZ and CNOT gates in the circuit;
- Mapping those operations to their twirled equivalences;
- Executing the modified circuit.


## Executing the modified circuit

```{code-cell} ipython3
from cirq import DensityMatrixSimulator, amplitude_damp

def execute(circuit, noise_level=0.003):
    """Returns Tr[ρ |00..⟩⟨00..|] where ρ is the state prepared by the circuit
    executed with depolarizing noise.
    """
    noisy_circuit = circuit.with_noise(amplitude_damp(noise_level))
    rho = DensityMatrixSimulator().simulate(noisy_circuit).final_density_matrix
    return rho[0, 0].real
```

If executed on a noiseless backend, `circuit_with_pt` and `circuit` are equivalent.
On a real backend, they have a different sensitivity to noise. The core idea of the PT technique is that,
`circuit_with_pt` is (hopefully) less sensitive Markovian to noise thanks to the randomized Pauli insertions.

```{code-cell} ipython3
# Ideal result
execute(circuit, noise_level=0)
```

```{code-cell} ipython3
# Unmitigated result
execute(circuit)
```

```{code-cell} ipython3
# Error-mitigated result (with PT)
execute(circuit_with_pt)
```

As a final remark, we stress that the low-level procedure that we have shown is exactly what {func}`.execute_with_ddd()` does behind the scenes.
Let's verify this fact: 

```{code-cell} ipython3
np.isclose(
  pt.execute_with_pt(circuit, execute, rule=xyxy_rule),
  execute(circuit_with_pt),
)
```
