---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.1
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# What additional options are available when using ZNE?

In the introductory section [How do I use ZNE?](zne-1-intro.myst), we used the function
{func}`execute_with_zne()` to evaluate error-mitigated expectation values with zero-noise extrapolation.
Beyond the positional arguments (`circuit`, `executor` and `observable`) that are common to all
error mitigation techniques, one can use additional keyword arguments for optional settings as shown in next code snippet:

+++

```
from mitiq import zne

zne_value = zne.execute_with_zne(
    circuit,
    executor,
    observable,
    scale_noise = <"noise scaling method imported from zne.scaling">,
    factory = <"extrapolation Factory imported from zne.inference">,
    num_to_average = <"number of repeated evaluations for each noise-scaled circuit">,
)
```

+++

The three main options are `scale_noise`, `factory` and `num_to_average`.
- The option `scale_noise` can be used to select a noise scaling method.
    More details are explained below.
- The option `factory` can be used to select an extrapolation method.
    More details are explained below.
- The option `num_to_average` can be used to average over multiple evaluations of each noise-scaled expectation value.

+++

In the next sections we explain in more details how noise scaling and extrapolation methods are represented in Mitiq 
and how they can be applied in practice.

+++

## Noise scaling functions

+++

To apply ZNE, we need to effectively increase the noise acting in a quantum computation. Instead of directly controlling the physical backend,
Mitiq achieves this task by *digital* noise scaling, i.e., with circuit manipulations that indirectly increase the effect of noise but keep the circuit logic unchanged.
More details on digital ZNE can be found in [What is the theory behind ZNE?](zne-5-theory.myst)

In Mitiq a noise scaling method is represented by a *noise scaling function* that takes as input a `circuit` and a real `scale_factor` and
returns a `scaled_circuit`. For a noiseless backend, `scaled_circuit` has the same effect as `circuit`. For a noisy backend, 
`scaled_circuit` is more sensitive to errors depending on the magnitude of `scale_factor`. 

