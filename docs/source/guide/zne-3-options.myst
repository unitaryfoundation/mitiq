---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.1
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# What additional options are available when using ZNE?

In the introductory section [How do I use ZNE?](zne-1-intro.myst), we used the function
{func}`execute_with_zne()` to evaluate error-mitigated expectation values with zero-noise extrapolation.
Beyond the positional arguments (`circuit`, `executor` and `observable`) that are common to all
error mitigation techniques, one can use additional keyword arguments for optional settings as shown in next code snippet:

+++

```
from mitiq import zne

zne_value = zne.execute_with_zne(
    circuit,
    executor,
    observable,
    scale_noise = <"noise scaling method imported from zne.scaling">,
    factory = <"extrapolation Factory imported from zne.inference">,
    num_to_average = <"number of repeated evaluations for each noise-scaled circuit">,
)
```

+++

The three main options are `scale_noise`, `factory` and `num_to_average`.
- The option `scale_noise` can be used to select a noise scaling method.
    More details are explained below.
- The option `factory` can be used to select an extrapolation method.
    More details are explained below.
- The option `num_to_average` can be used to average over multiple evaluations of each noise-scaled expectation value.

+++

In the next sections we explain in more details how noise scaling and extrapolation methods are represented in Mitiq 
and how they can be applied in practice.

+++

## Noise scaling functions

+++

To apply ZNE, we need to effectively increase the noise acting in a quantum computation. Instead of directly controlling the physical backend,
Mitiq achieves this task by *digital* noise scaling, i.e., with circuit manipulations that indirectly increase the effect of noise but keep the circuit logic unchanged.
More details on digital ZNE can be found in [What is the theory behind ZNE?](zne-5-theory.myst)

In Mitiq a noise scaling method is represented by a *noise scaling function* that takes as input a `circuit` and a real `scale_factor` and
returns a `scaled_circuit`. For a noiseless backend, `scaled_circuit` has the same effect as `circuit`. For a noisy backend, 
`scaled_circuit` is more sensitive to errors depending on the magnitude of `scale_factor`. 

### Unitary Folding 

Mitiq provides several noise scaling functions. Most of them are based on the repeated application of the *unitary folding* technique in
which a unitary $G$ is mapped as follows:

$$G \longrightarrow G G^\dagger G.$$

If this is applied to individual gates of a `circuit`, we call it *local folding*. If $G$ is the entire `circuit`, we call it *global folding*.

The Mitiq function for global folding is:

- {func}`.fold_global()`.

The Mitiq functions for local folding are: 
- {func}`.fold_gates_at_random()`;
- {func}`.fold_gates_from_left()`;
- {func}`.fold_gates_from_right()`;
- {func}`.fold_all()`.

There are multiple functions for local folding since it can be applied to the gates of a circuit according to different orderings:
at random, from left (starting from the initial gates), from right (starting from the final gates), etc.. 
For more details on folding functions, we suggest to click on the functions listed above and check the associated API docs.

If not specified by the user, the default noise scaling method in Mitiq is {func}`.fold_gates_at_random()`.
Custom noise-scaling functions can also be defined by the user, as shown
in [What happens when I use ZNE ?](zne-4-low-level.myst).

+++

**Note:** *All folding functions can be applied to circuits defined in any supported frontend. For example, in the next code cells we use Cirq to represent quantum circuits.*

+++

#### The special case of odd integer scale factors

+++

For any noise scaling function, if `scale_factor` is equal to 1, the input circuit is unchanged
and it is subject to the base noise of the backend.

Both local and global folding, if applied uniformly to all the gates of `circuit`, produce a `scaled_circuit` that has 3 times more gates than the input `circuit`.
This corresponds to the `scale_factor=3` setting. For example:

```{code-cell} ipython3
import cirq
from mitiq import zne

# Get a circuit to fold
qreg = cirq.LineQubit.range(2)
circuit = cirq.Circuit(cirq.ops.H.on(qreg[0]), cirq.ops.CNOT.on(qreg[0], qreg[1]))
print("Original circuit:", circuit, sep="\n")

# Apply local folding
scaled_circuit = zne.scaling.fold_gates_at_random(circuit, scale_factor=3)
print("Locally folded circuit:", scaled_circuit, sep="\n")

# Apply global folding
scaled_circuit = zne.scaling.fold_global(circuit, scale_factor=3)
print("Globally folded circuit:", scaled_circuit, sep="\n")
```

The same trick can be generalized to any odd integer `scale_factor`.
In this case, folding functions apply the mapping $G \longrightarrow G (G^\dagger G)^{(\lambda - 1)/2}$. For example:

```{code-cell} ipython3
num_gates = len(list(circuit.all_operations()))
for scale_factor in [1, 3, 5, 7]:
    scaled_circuit = zne.scaling.fold_global(circuit, scale_factor)
    scaled_num_gates = len(list(scaled_circuit.all_operations()))
    print(f"For scale_factor={scale_factor}, the number of gates was scaled by {scaled_num_gates / num_gates}")
```

**Note:** *When `scale_factor` is an odd integer, the number of gates is scaled exactly as dictated by the value of `scale_factor`.
In this case, since all gates are folded the same number of times, the three local folding functions 
{func}`.fold_gates_at_random()`, {func}`.fold_gates_from_left()` and {func}`.fold_gates_from_right()` have the same (deterministic) effect.*

+++
