---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.14.1
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

```{code-cell} ipython3
%load_ext nb_black
```

```{code-cell} ipython3
import warnings
warnings.simplefilter("ignore", UserWarning)
import numpy as np
from cirq import (
    CXPowGate,
    MixedUnitaryChannel,
    Rx,
    Rz,
    I,
    X,
    Y,
    Z,
    LineQubit,
    Circuit,
    ops,
    unitary,
)
from mitiq import Executor, Observable, PauliString
from mitiq.interface.mitiq_cirq import compute_density_matrix
from mitiq.cdr import generate_training_circuits
from mitiq.cdr._testing import random_x_z_cnot_circuit
from mitiq.pec.representations.biased_noise import (
    represent_operation_with_local_biased_noise)
from mitiq.pec.representations.learning import (
    biased_noise_loss_function,
    learn_biased_noise_parameters,
)
```

```{code-cell} ipython3
seed = 1
rng = np.random.RandomState(seed)
circuit = random_x_z_cnot_circuit(LineQubit.range(2), n_moments=5, random_state=rng)

pec_kwargs = {"num_samples": 5000, "random_state": 1}

observable = Observable(PauliString("XZ"), PauliString("YY"))

CNOT_ops = list(circuit.findall_operations_with_gate_type(CXPowGate))
Rx_ops = list(circuit.findall_operations_with_gate_type(Rx))
Rz_ops = list(circuit.findall_operations_with_gate_type(Rz))


operation = Circuit(CNOT_ops[0][1])
operations = [operation]


def ideal_execute(circ: Circuit) -> np.ndarray:
    return compute_density_matrix(circ, noise_level=(0.0,))


ideal_executor = Executor(ideal_execute)
```

```{code-cell} ipython3
epsilon = 0.05
eta = 0


def biased_noise_channel(epsilon: float, eta: float) -> MixedUnitaryChannel:
    a = 1 - epsilon
    b = epsilon * (3 * eta + 1) / (3 * (eta + 1))
    c = epsilon / (3 * (eta + 1))

    mix = [
        (a, unitary(I)),
        (b, unitary(Z)),
        (c, unitary(X)),
        (c, unitary(Y)),
    ]
    return ops.MixedUnitaryChannel(mix)


def noisy_execute(circ: Circuit) -> np.ndarray:
    noisy_circ = circ.copy()[0:0]

    for op in circ.all_operations():
        noisy_circ.append(op)
        if isinstance(op.gate, CXPowGate):
            qubits = op.qubits
            noisy_circ.append(biased_noise_channel(epsilon, eta)(qubits[0]))
            noisy_circ.append(biased_noise_channel(epsilon, eta)(qubits[1]))

    return ideal_execute(noisy_circ)


noisy_executor = Executor(noisy_execute)
```

```{code-cell} ipython3
num_training_circuits = 5
fraction_non_clifford = 0.2

training_circuits = generate_training_circuits(
    circuit=circuit,
    num_training_circuits=num_training_circuits,
    fraction_non_clifford=fraction_non_clifford,
    method_select="uniform",
    method_replace="closest",
)
```

```{code-cell} ipython3
ideal_values = np.array(
    [ideal_executor.evaluate(t, observable) for t in training_circuits]
)
print(ideal_values)
```

```{code-cell} ipython3
epsilons = np.linspace(0, 1, 51)
etas = np.linspace(0, 1000, 51)


from mitiq.pec.representations.learning import biased_noise_loss_function
loss_epsilons = [biased_noise_loss_function([eps, eta], operations, training_circuits, ideal_values, noisy_executor, pec_kwargs, observable) for eps in epsilons]
loss_etas = [biased_noise_loss_function([epsilon, et], operations, training_circuits, ideal_values, noisy_executor, pec_kwargs, observable) for et in etas]
```

```{code-cell} ipython3
from matplotlib import pyplot as plt
_ = plt.plot(epsilons, loss_epsilons)
print(loss_epsilons)
```

```{code-cell} ipython3
_ = plt.plot(etas, loss_etas)
print(loss_etas)
```

```{code-cell} ipython3
reps_eta1000 = [represent_operation_with_local_biased_noise(operation, epsilons[25], eta)]
from mitiq.pec import execute_with_pec
mitigated_values = np.array(
        [
            execute_with_pec(
                circuit=training_circuit,
                observable=observable,
                executor=noisy_executor,
                representations=reps,
                full_output=False,
                **pec_kwargs,
            )
            for training_circuit in training_circuits
        ]
    )
```

```{code-cell} ipython3
print(mitigated_values)
```

```{code-cell} ipython3
rep_eta1000 = reps_eta1000[0]
print(rep_eta1000)
print(sum(rep_eta1000.coeffs))
rep_eta1000.norm
```

```{code-cell} ipython3
reps_zero_bias = [represent_operation_with_local_biased_noise(operation, epsilons[25], 0)]
from mitiq.pec import execute_with_pec
mitigated_values = np.array(
        [
            execute_with_pec(
                circuit=training_circuit,
                observable=observable,
                executor=noisy_executor,
                representations=reps,
                full_output=False,
                **pec_kwargs,
            )
            for training_circuit in training_circuits
        ]
    )
```

```{code-cell} ipython3
rep_zero_bias = reps_zero_bias[0]
print(rep_zero_bias)
print(sum(rep_zero_bias.coeffs))
rep_zero_bias.norm
```

```{code-cell} ipython3
print(np.sum(abs(mitigated_values.reshape(-1, 1) - ideal_values.reshape(-1, 1)) ** 2) / len(
        training_circuits
    ))
```

```{code-cell} ipython3
new_loss_epsilons = [0.07370759460286282, 0.07639655970309352, 0.07843127884796323, 0.07955296922016994, 0.08319542677766378, 0.08459302870106708, 0.08600112824010067, 0.08739294260499597, 0.09481508743741578, 0.1016416441019076, 0.1071852746114071, 0.11708244309390206, 0.13382736032643627, 0.13597523759036656, 0.14894898416894836, 0.18164819771586033, 0.16725127630791867, 0.1644746722266169, 0.22110645806874799, 0.2663778215573302, 0.3830885461316802, 0.5428413593563908, 0.6995357984994958, 1.9462501916319983, 4.409256470375931, 0.03765101764111055, 0.03765101764111094, 0.0005049324510191821, 0.002421035120589347, 0.03796229713855253, 0.016863221728163257, 0.0019220973374654087, 0.0011264235673087313, 0.00020276193050980225, 0.00037241281842736795, 0.0006539885362036017, 0.0015218448212525556, 0.0038379285885312663, 0.005654925802312079, 0.006706284143846721, 0.007724858462625869, 0.008704061976545299, 0.00906138909132799, 0.00945867278279448, 0.009882517960822321, 0.010323228549466181, 0.012058775855380035, 0.012837864634491556, 0.013576464787420726, 0.013908055357048487]
plt.plot(new_loss_epsilons)
```

```{code-cell} ipython3
reps_depolarizing = [represent_operation_with_local_biased_noise(operation, eps, 0) for eps in epsilons]
[rep.norm for rep in reps_depolarizing]
```

```{code-cell} ipython3
from mitiq.pec.representations.depolarizing import represent_operation_with_local_depolarizing_noise
reps_depolarizing = [represent_operation_with_local_depolarizing_noise(operation, eps) for eps in epsilons]
[rep.norm for rep in reps_depolarizing]
```

```{code-cell} ipython3
from mitiq.pec.representations.depolarizing import represent_operation_with_global_depolarizing_noise
reps_depolarizing = [represent_operation_with_global_depolarizing_noise(operation, eps) for eps in epsilons]
[rep.norm for rep in reps_depolarizing]
```

```{code-cell} ipython3
small_epsilons = np.linspace(0, 0.2, 51)
reps_zero_bias_small_eps = [represent_operation_with_local_biased_noise(operation, se, 0) for se in small_epsilons]
reps_depolarizing_small_eps = [represent_operation_with_local_depolarizing_noise(operation, se) for se in small_epsilons]
small_eps_norm = [rep.norm for rep in reps_zero_bias_small_eps]
print(small_eps_norm)
np.array([rep.norm for rep in reps_depolarizing_small_eps])-np.array([small_eps_norm])
```

```{code-cell} ipython3
loss_small_epsilons = [biased_noise_loss_function([eps, 0], operations, training_circuits, ideal_values, noisy_executor, pec_kwargs, observable) for eps in small_epsilons]
_ = plt.plot(small_epsilons, loss_small_epsilons)
print(loss_small_epsilons)
```

```{code-cell} ipython3
offset = 0.01
epsilon0 = (1 + offset) * epsilon
eta0 = eta + 0.1 * offset
from mitiq.pec.representations.learning import learn_biased_noise_parameters

import timeit

start = timeit.default_timer()
[epsilon_opt, eta_opt, success] = learn_biased_noise_parameters(
    operations_to_learn=operations,
    circuit=circuit,
    ideal_executor=ideal_executor,
    noisy_executor=noisy_executor,
    pec_kwargs=pec_kwargs,
    num_training_circuits=5,
    fraction_non_clifford=0.2,
    epsilon0=epsilon0,
    eta0=eta0,
    observable=observable,
)
end = timeit.default_timer()
print(end - start)
```

```{code-cell} ipython3
print(epsilon_opt)
print(epsilon0)
print(epsilon)
print(eta_opt)
print(eta0)
print(eta)
print(success)
```

```{code-cell} ipython3
smaller_epsilons = small_epsilons / 2
loss_smaller_epsilons = (
    [
        biased_noise_loss_function(
            [eps, 0],
            operations,
            training_circuits,
            ideal_values,
            noisy_executor,
            pec_kwargs,
            observable,
        )
        for eps in smaller_epsilons
    ],
)
_ = plt.plot(smaller_epsilons, loss_smaller_epsilons)
```

```{code-cell} ipython3
noisy_circuit = circuit.copy()[0:0]

for op in circuit.all_operations():
    noisy_circuit.append(op)
    if isinstance(op.gate, operation.all_operations.gate):
        qubits = op.qubits
        noisy_circuit.append(biased_noise_channel(epsilon, eta)(qubits[0]))
        noisy_circuit.append(biased_noise_channel(epsilon, eta)(qubits[1]))
print(noisy_circuit)
```

```{code-cell} ipython3
def biased_noise_channel(epsilon: float, eta: float) -> MixedUnitaryChannel:
    a = 1 - epsilon
    b = epsilon * (3 * eta + 1) / (3 * (eta + 1))
    c = epsilon / (3 * (eta + 1))

    mix = [
        (a, unitary(I)),
        (b, unitary(Z)),
        (c, unitary(X)),
        (c, unitary(Y)),
    ]
    return ops.MixedUnitaryChannel(mix)


def noisy_execute(circ: Circuit) -> np.ndarray:
    noisy_circ = circ.copy()[0:0]

    for op in circ.all_operations():
        noisy_circ.append(op)
        if isinstance(op.gate, CXPowGate):
            qubits = op.qubits
            noisy_circ.append(biased_noise_channel(epsilon, eta)(qubits[0]))
            noisy_circ.append(biased_noise_channel(epsilon, eta)(qubits[1]))

    return ideal_execute(noisy_circ)


noisy_executor = Executor(noisy_execute)
```
